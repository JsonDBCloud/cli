# CI Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add a CI quality gate with ESLint, Prettier, Vitest (unit + integration tests), and a GitHub Actions workflow.

**Architecture:** Separate `ci.yml` workflow alongside existing `publish.yml`. Tooling: ESLint flat config + Prettier for code quality, Vitest for testing with co-located test files. Tests mock `fetch` globally for API calls.

**Tech Stack:** ESLint 9+, typescript-eslint, Prettier, Vitest, GitHub Actions

---

### Task 1: Install Dev Dependencies

**Files:**
- Modify: `package.json`

**Step 1: Install linting dependencies**

```bash
npm install -D eslint @eslint/js typescript-eslint prettier
```

**Step 2: Install testing dependencies**

```bash
npm install -D vitest
```

**Step 3: Commit**

```bash
git add package.json package-lock.json
git commit -m "chore: add eslint, prettier, vitest dev dependencies"
```

---

### Task 2: Configure ESLint

**Files:**
- Create: `eslint.config.js`

**Step 1: Create flat config**

```js
import eslint from "@eslint/js";
import tseslint from "typescript-eslint";

export default tseslint.config(
  eslint.configs.recommended,
  ...tseslint.configs.recommended,
  {
    ignores: ["dist/", "node_modules/"],
  },
);
```

Note: This requires `"type": "module"` in package.json OR the file must be `eslint.config.mjs`. Since the project uses CommonJS (`"module": "commonjs"` in tsconfig), use `eslint.config.mjs` to avoid changing the module system.

**Step 2: Rename to .mjs**

Actually create the file as `eslint.config.mjs` (not `.js`).

**Step 3: Add lint scripts to package.json**

Add to `"scripts"`:
```json
"lint": "eslint src/",
"lint:fix": "eslint src/ --fix"
```

**Step 4: Run lint to verify config works**

```bash
npm run lint
```

Expected: May show warnings/errors from existing code. That's fine — we'll fix in Task 4.

**Step 5: Commit**

```bash
git add eslint.config.mjs package.json
git commit -m "chore: add eslint flat config with typescript-eslint"
```

---

### Task 3: Configure Prettier

**Files:**
- Create: `.prettierrc`
- Create: `.prettierignore`

**Step 1: Check existing code style**

Look at the source files. The existing style uses:
- Double quotes
- Semicolons
- 2-space indentation
- Trailing commas

**Step 2: Create `.prettierrc`**

```json
{
  "semi": true,
  "singleQuote": false,
  "tabWidth": 2,
  "trailingComma": "all",
  "printWidth": 120
}
```

**Step 3: Create `.prettierignore`**

```
dist/
node_modules/
```

**Step 4: Add format scripts to package.json**

Add to `"scripts"`:
```json
"format": "prettier --write 'src/**/*.ts'",
"format:check": "prettier --check 'src/**/*.ts'"
```

**Step 5: Run format check**

```bash
npm run format:check
```

Expected: May show files that need formatting. That's fine.

**Step 6: Commit config files**

```bash
git add .prettierrc .prettierignore package.json
git commit -m "chore: add prettier config"
```

---

### Task 4: Fix Existing Lint and Format Issues

**Files:**
- Modify: Various files in `src/`

**Step 1: Auto-fix formatting**

```bash
npm run format
```

**Step 2: Auto-fix lint issues**

```bash
npm run lint:fix
```

**Step 3: Manually fix remaining lint errors**

Check `npm run lint` output. Common issues to expect:
- `@typescript-eslint/no-explicit-any` — the codebase uses `any` in several places (e.g., `src/commands/documents.ts:13,47,75,99`, `src/index.ts`). Either fix with proper types or add targeted eslint-disable comments for cases where the API response shape is genuinely unknown.
- `@typescript-eslint/no-unused-vars` — check for any unused imports.

For API response types where `any` is intentional (parsing unknown JSON from the server), disable per-line:
```ts
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const data: any = await res.json().catch(() => ({}));
```

Or add a rule override in `eslint.config.mjs` to downgrade `no-explicit-any` to warn:
```js
{
  rules: {
    "@typescript-eslint/no-explicit-any": "warn",
  },
}
```

**Step 4: Verify clean lint + format**

```bash
npm run lint && npm run format:check
```

Expected: No errors, no formatting issues.

**Step 5: Verify build still works**

```bash
npm run typecheck && npm run build
```

Expected: Clean output, no errors.

**Step 6: Commit**

```bash
git add -A
git commit -m "style: fix lint and formatting issues across codebase"
```

---

### Task 5: Configure Vitest

**Files:**
- Create: `vitest.config.ts`
- Modify: `package.json`
- Modify: `tsconfig.json`

**Step 1: Create vitest config**

```ts
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    include: ["src/**/*.test.ts"],
    globals: true,
  },
});
```

**Step 2: Add test script to package.json**

Add to `"scripts"`:
```json
"test": "vitest run"
```

**Step 3: Exclude test files from tsc build**

Modify `tsconfig.json` to exclude test files from the compiled output:
```json
"exclude": ["node_modules", "dist", "src/**/*.test.ts", "vitest.config.ts"]
```

**Step 4: Run test to verify config**

```bash
npm test
```

Expected: "No test files found" or similar — that's correct, we haven't written tests yet.

**Step 5: Commit**

```bash
git add vitest.config.ts package.json tsconfig.json
git commit -m "chore: configure vitest test runner"
```

---

### Task 6: Unit Tests — config.ts

**Files:**
- Create: `src/lib/config.test.ts`

Tests for `loadConfig()`, `saveConfig()`, `clearConfig()`, `getConfigPath()`.

**Step 1: Write the tests**

```ts
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";

// Must mock before importing the module under test
vi.mock("fs");
vi.mock("os");

// Re-import after mock setup
const { loadConfig, saveConfig, clearConfig, getConfigPath } = await import("./config");

const mockedFs = vi.mocked(fs);
const mockedOs = vi.mocked(os);

describe("config", () => {
  beforeEach(() => {
    vi.resetAllMocks();
    mockedOs.homedir.mockReturnValue("/home/testuser");
    // Clear env vars
    delete process.env.JSONDB_API_KEY;
    delete process.env.JSONDB_PROJECT;
    delete process.env.JSONDB_NAMESPACE;
    delete process.env.JSONDB_BASE_URL;
  });

  describe("getConfigPath", () => {
    it("returns path under ~/.config/jsondb", () => {
      expect(getConfigPath()).toBe(
        path.join("/home/testuser", ".config", "jsondb", "credentials.json"),
      );
    });
  });

  describe("loadConfig", () => {
    it("returns config from env vars when JSONDB_API_KEY is set", () => {
      process.env.JSONDB_API_KEY = "jdb_sk_test_abc123";
      process.env.JSONDB_PROJECT = "myproject";
      process.env.JSONDB_BASE_URL = "https://custom.api.com";

      const config = loadConfig();
      expect(config).toEqual({
        apiKey: "jdb_sk_test_abc123",
        project: "myproject",
        baseUrl: "https://custom.api.com",
      });
    });

    it("uses defaults for project and baseUrl when only API key is in env", () => {
      process.env.JSONDB_API_KEY = "jdb_sk_test_abc123";

      const config = loadConfig();
      expect(config).toEqual({
        apiKey: "jdb_sk_test_abc123",
        project: "v1",
        baseUrl: "https://api.jsondb.cloud",
      });
    });

    it("falls back to JSONDB_NAMESPACE if JSONDB_PROJECT is not set", () => {
      process.env.JSONDB_API_KEY = "jdb_sk_test_abc123";
      process.env.JSONDB_NAMESPACE = "legacy-ns";

      const config = loadConfig();
      expect(config?.project).toBe("legacy-ns");
    });

    it("reads from credentials file when no env vars", () => {
      const fileConfig = {
        apiKey: "jdb_sk_live_fromfile",
        project: "prod",
        baseUrl: "https://api.jsondb.cloud",
      };
      mockedFs.readFileSync.mockReturnValue(JSON.stringify(fileConfig));

      const config = loadConfig();
      expect(config).toEqual(fileConfig);
    });

    it("returns null when no env vars and no credentials file", () => {
      mockedFs.readFileSync.mockImplementation(() => {
        throw new Error("ENOENT");
      });

      const config = loadConfig();
      expect(config).toBeNull();
    });
  });

  describe("saveConfig", () => {
    it("creates config directory and writes file with restricted permissions", () => {
      mockedFs.existsSync.mockReturnValue(false);

      saveConfig({
        apiKey: "jdb_sk_test_abc",
        project: "default",
        baseUrl: "https://api.jsondb.cloud",
      });

      expect(mockedFs.mkdirSync).toHaveBeenCalledWith(
        path.join("/home/testuser", ".config", "jsondb"),
        { recursive: true },
      );
      expect(mockedFs.writeFileSync).toHaveBeenCalledWith(
        path.join("/home/testuser", ".config", "jsondb", "credentials.json"),
        expect.any(String),
        { mode: 0o600 },
      );
    });

    it("skips mkdir if config dir already exists", () => {
      mockedFs.existsSync.mockReturnValue(true);

      saveConfig({
        apiKey: "jdb_sk_test_abc",
        project: "default",
        baseUrl: "https://api.jsondb.cloud",
      });

      expect(mockedFs.mkdirSync).not.toHaveBeenCalled();
    });
  });

  describe("clearConfig", () => {
    it("deletes the credentials file", () => {
      clearConfig();
      expect(mockedFs.unlinkSync).toHaveBeenCalledWith(
        path.join("/home/testuser", ".config", "jsondb", "credentials.json"),
      );
    });

    it("does not throw if file does not exist", () => {
      mockedFs.unlinkSync.mockImplementation(() => {
        throw new Error("ENOENT");
      });

      expect(() => clearConfig()).not.toThrow();
    });
  });
});
```

**Step 2: Run tests to verify they pass**

```bash
npm test
```

Expected: All tests pass. Note: The mocking approach may need adjustment depending on how Vitest handles the `fs`/`os` module mocking with the CommonJS output. If top-level await for dynamic import doesn't work, restructure to use `vi.importActual` or inline requires.

**Step 3: Commit**

```bash
git add src/lib/config.test.ts
git commit -m "test: add unit tests for config module"
```

---

### Task 7: Unit Tests — client.ts

**Files:**
- Create: `src/lib/client.test.ts`

Tests for `ApiClient` URL construction, headers, HTTP method delegation.

**Step 1: Write the tests**

```ts
import { describe, it, expect, vi, beforeEach } from "vitest";
import { ApiClient } from "./client";

const mockFetch = vi.fn();
vi.stubGlobal("fetch", mockFetch);

describe("ApiClient", () => {
  const config = {
    apiKey: "jdb_sk_test_abc123",
    project: "myproject",
    baseUrl: "https://api.jsondb.cloud",
  };

  let client: ApiClient;

  beforeEach(() => {
    vi.resetAllMocks();
    mockFetch.mockResolvedValue(new Response(JSON.stringify({ ok: true }), { status: 200 }));
    client = new ApiClient(config);
  });

  describe("URL construction", () => {
    it("builds URL with project prefix", async () => {
      await client.get("users/abc");
      expect(mockFetch).toHaveBeenCalledWith(
        "https://api.jsondb.cloud/myproject/users/abc",
        expect.any(Object),
      );
    });

    it("strips trailing slash from baseUrl", async () => {
      const c = new ApiClient({ ...config, baseUrl: "https://api.jsondb.cloud/" });
      await c.get("users/abc");
      expect(mockFetch).toHaveBeenCalledWith(
        "https://api.jsondb.cloud/myproject/users/abc",
        expect.any(Object),
      );
    });
  });

  describe("headers", () => {
    it("includes Authorization bearer token", async () => {
      await client.get("test");
      const callArgs = mockFetch.mock.calls[0];
      expect(callArgs[1].headers).toMatchObject({
        Authorization: "Bearer jdb_sk_test_abc123",
        "Content-Type": "application/json",
      });
    });

    it("merges Accept header when provided", async () => {
      await client.get("test", "text/csv");
      const callArgs = mockFetch.mock.calls[0];
      expect(callArgs[1].headers).toMatchObject({
        Accept: "text/csv",
      });
    });
  });

  describe("HTTP methods", () => {
    it("GET sends correct method", async () => {
      await client.get("path");
      expect(mockFetch.mock.calls[0][1].method).toBe("GET");
    });

    it("POST sends JSON body", async () => {
      await client.post("path", { name: "test" });
      const callArgs = mockFetch.mock.calls[0];
      expect(callArgs[1].method).toBe("POST");
      expect(callArgs[1].body).toBe(JSON.stringify({ name: "test" }));
    });

    it("POST sends undefined body when no body provided", async () => {
      await client.post("path");
      expect(mockFetch.mock.calls[0][1].body).toBeUndefined();
    });

    it("postRaw sends raw body with custom content type", async () => {
      await client.postRaw("path", "csv,data", "text/csv");
      const callArgs = mockFetch.mock.calls[0];
      expect(callArgs[1].method).toBe("POST");
      expect(callArgs[1].body).toBe("csv,data");
      expect(callArgs[1].headers["Content-Type"]).toBe("text/csv");
    });

    it("PUT sends JSON body", async () => {
      await client.put("path", { updated: true });
      const callArgs = mockFetch.mock.calls[0];
      expect(callArgs[1].method).toBe("PUT");
      expect(callArgs[1].body).toBe(JSON.stringify({ updated: true }));
    });

    it("PATCH sends JSON body", async () => {
      await client.patch("path", { field: "value" });
      const callArgs = mockFetch.mock.calls[0];
      expect(callArgs[1].method).toBe("PATCH");
    });

    it("PATCH accepts custom content type", async () => {
      await client.patch("path", { field: "value" }, "application/merge-patch+json");
      const callArgs = mockFetch.mock.calls[0];
      expect(callArgs[1].headers["Content-Type"]).toBe("application/merge-patch+json");
    });

    it("DELETE sends correct method", async () => {
      await client.delete("path");
      expect(mockFetch.mock.calls[0][1].method).toBe("DELETE");
    });
  });

  describe("rawGet", () => {
    it("sends GET without project prefix", async () => {
      await client.rawGet("/admin/status");
      expect(mockFetch).toHaveBeenCalledWith(
        "https://api.jsondb.cloud/admin/status",
        expect.any(Object),
      );
    });
  });
});
```

**Step 2: Run tests**

```bash
npm test
```

Expected: All tests pass.

**Step 3: Commit**

```bash
git add src/lib/client.test.ts
git commit -m "test: add unit tests for API client"
```

---

### Task 8: Unit Tests — output.ts

**Files:**
- Create: `src/lib/output.test.ts`

Tests for `printTable`, `printJson`, `success`, `error`, `warn`.

**Step 1: Write the tests**

```ts
import { describe, it, expect, vi, beforeEach } from "vitest";

// We need to test both TTY and non-TTY behavior
// The module reads isTTY at import time, so we test non-TTY path
// (test environment has isTTY = false)

describe("output (non-TTY)", () => {
  let output: typeof import("./output");

  beforeEach(async () => {
    vi.resetModules();
    output = await import("./output");
  });

  describe("success", () => {
    it("prints OK prefix in non-TTY mode", () => {
      const spy = vi.spyOn(console, "log").mockImplementation(() => {});
      output.success("done");
      expect(spy).toHaveBeenCalledWith("OK: done");
      spy.mockRestore();
    });
  });

  describe("error", () => {
    it("prints ERROR prefix", () => {
      const spy = vi.spyOn(console, "error").mockImplementation(() => {});
      output.error("something broke");
      expect(spy).toHaveBeenCalledWith("ERROR: something broke");
      spy.mockRestore();
    });

    it("prints suggestion on second line", () => {
      const spy = vi.spyOn(console, "error").mockImplementation(() => {});
      output.error("bad input", "Try again");
      expect(spy).toHaveBeenCalledTimes(2);
      expect(spy).toHaveBeenCalledWith("Try again");
      spy.mockRestore();
    });
  });

  describe("warn", () => {
    it("prints WARN prefix", () => {
      const spy = vi.spyOn(console, "log").mockImplementation(() => {});
      output.warn("careful");
      expect(spy).toHaveBeenCalledWith("WARN: careful");
      spy.mockRestore();
    });
  });

  describe("printJson", () => {
    it("prints compact JSON in non-TTY mode", () => {
      const spy = vi.spyOn(console, "log").mockImplementation(() => {});
      output.printJson({ key: "value" });
      expect(spy).toHaveBeenCalledWith(JSON.stringify({ key: "value" }));
      spy.mockRestore();
    });

    it("prints compact JSON when raw=true", () => {
      const spy = vi.spyOn(console, "log").mockImplementation(() => {});
      output.printJson({ key: "value" }, true);
      expect(spy).toHaveBeenCalledWith(JSON.stringify({ key: "value" }));
      spy.mockRestore();
    });
  });

  describe("printTable", () => {
    it("prints headers, separator, and rows with padding", () => {
      const lines: string[] = [];
      const spy = vi.spyOn(console, "log").mockImplementation((...args: unknown[]) => {
        lines.push(String(args[0]));
      });

      output.printTable(["Name", "Age"], [
        ["Alice", "30"],
        ["Bob", "25"],
      ]);

      expect(lines).toHaveLength(4); // header + separator + 2 rows
      expect(lines[0]).toContain("Name");
      expect(lines[0]).toContain("Age");
      expect(lines[1]).toMatch(/^-+/); // separator line
      expect(lines[2]).toContain("Alice");
      expect(lines[3]).toContain("Bob");

      spy.mockRestore();
    });

    it("pads columns to the widest value", () => {
      const lines: string[] = [];
      const spy = vi.spyOn(console, "log").mockImplementation((...args: unknown[]) => {
        lines.push(String(args[0]));
      });

      output.printTable(["ID", "Description"], [
        ["1", "Short"],
        ["2", "A much longer description"],
      ]);

      // Both rows should have same length due to padding
      expect(lines[2].length).toBe(lines[3].length);

      spy.mockRestore();
    });
  });
});
```

**Step 2: Run tests**

```bash
npm test
```

Expected: All tests pass.

**Step 3: Commit**

```bash
git add src/lib/output.test.ts
git commit -m "test: add unit tests for output formatting"
```

---

### Task 9: Integration Tests — Document Commands

**Files:**
- Create: `src/commands/documents.test.ts`

Tests the command handlers end-to-end: arguments in -> fetch called -> output produced.

**Step 1: Write the tests**

```ts
import { describe, it, expect, vi, beforeEach } from "vitest";
import { ApiClient } from "../lib/client";
import { getCommand, deleteCommand, listCollectionsCommand, listDocumentsCommand } from "./documents";

const mockFetch = vi.fn();
vi.stubGlobal("fetch", mockFetch);

function mockResponse(body: unknown, status = 200): Response {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

describe("document commands", () => {
  const config = {
    apiKey: "jdb_sk_test_abc123",
    project: "testproject",
    baseUrl: "https://api.jsondb.cloud",
  };
  let client: ApiClient;

  beforeEach(() => {
    vi.resetAllMocks();
    client = new ApiClient(config);
    // Prevent process.exit from actually exiting
    vi.spyOn(process, "exit").mockImplementation((code?: number | string | null | undefined) => {
      throw new Error(`process.exit(${code})`);
    });
  });

  describe("getCommand", () => {
    it("fetches and prints a document", async () => {
      const doc = { _id: "usr_abc", name: "Alice" };
      mockFetch.mockResolvedValue(mockResponse(doc));
      const spy = vi.spyOn(console, "log").mockImplementation(() => {});

      await getCommand("users/usr_abc", client, {});

      expect(mockFetch).toHaveBeenCalledWith(
        "https://api.jsondb.cloud/testproject/users/usr_abc",
        expect.objectContaining({ method: "GET" }),
      );
      expect(spy).toHaveBeenCalled();
      spy.mockRestore();
    });

    it("exits with error on non-ok response", async () => {
      mockFetch.mockResolvedValue(mockResponse({ error: { message: "Not found" } }, 404));
      const spy = vi.spyOn(console, "error").mockImplementation(() => {});

      await expect(getCommand("users/missing", client, {})).rejects.toThrow("process.exit(1)");
      spy.mockRestore();
    });
  });

  describe("deleteCommand", () => {
    it("sends DELETE and prints success", async () => {
      mockFetch.mockResolvedValue(new Response(null, { status: 204 }));
      const spy = vi.spyOn(console, "log").mockImplementation(() => {});

      await deleteCommand("users/usr_abc", client);

      expect(mockFetch.mock.calls[0][1].method).toBe("DELETE");
      spy.mockRestore();
    });
  });

  describe("listCollectionsCommand", () => {
    it("extracts unique collection names from documents", async () => {
      const data = {
        data: [
          { $collection: "users", _id: "1" },
          { $collection: "users", _id: "2" },
          { $collection: "posts", _id: "3" },
        ],
      };
      mockFetch.mockResolvedValue(mockResponse(data));
      const lines: string[] = [];
      const spy = vi.spyOn(console, "log").mockImplementation((...args: unknown[]) => {
        lines.push(String(args[0]));
      });

      await listCollectionsCommand(client);

      expect(lines).toEqual(["posts", "users"]); // sorted
      spy.mockRestore();
    });
  });

  describe("listDocumentsCommand", () => {
    it("fetches with limit and prints result", async () => {
      const data = { data: [{ _id: "1" }], total: 1 };
      mockFetch.mockResolvedValue(mockResponse(data));
      const spy = vi.spyOn(console, "log").mockImplementation(() => {});

      await listDocumentsCommand("users", client, { limit: "5" });

      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining("users?limit=5"),
        expect.any(Object),
      );
      spy.mockRestore();
    });
  });
});
```

**Step 2: Run tests**

```bash
npm test
```

Expected: All tests pass.

**Step 3: Commit**

```bash
git add src/commands/documents.test.ts
git commit -m "test: add integration tests for document commands"
```

---

### Task 10: Integration Tests — Login Command

**Files:**
- Create: `src/commands/login.test.ts`

**Step 1: Write the tests**

```ts
import { describe, it, expect, vi, beforeEach } from "vitest";
import * as config from "../lib/config";

vi.mock("../lib/config");

const mockedConfig = vi.mocked(config);

import { loginCommand } from "./login";

describe("loginCommand", () => {
  beforeEach(() => {
    vi.resetAllMocks();
    mockedConfig.getConfigPath.mockReturnValue("/home/test/.config/jsondb/credentials.json");
    vi.spyOn(process, "exit").mockImplementation((code?: number | string | null | undefined) => {
      throw new Error(`process.exit(${code})`);
    });
  });

  it("saves config when valid API key is provided via options", async () => {
    const spy = vi.spyOn(console, "log").mockImplementation(() => {});

    await loginCommand({ apiKey: "jdb_sk_test_validkey" });

    expect(mockedConfig.saveConfig).toHaveBeenCalledWith({
      apiKey: "jdb_sk_test_validkey",
      project: "default",
      baseUrl: "https://api.jsondb.cloud",
    });
    spy.mockRestore();
  });

  it("exits with error for invalid API key format", async () => {
    const spy = vi.spyOn(console, "error").mockImplementation(() => {});

    await expect(
      loginCommand({ apiKey: "invalid_key_format" }),
    ).rejects.toThrow("process.exit(1)");

    expect(mockedConfig.saveConfig).not.toHaveBeenCalled();
    spy.mockRestore();
  });

  it("uses custom project and baseUrl when provided", async () => {
    const spy = vi.spyOn(console, "log").mockImplementation(() => {});

    await loginCommand({
      apiKey: "jdb_sk_test_validkey",
      project: "custom",
      baseUrl: "https://custom.api.com",
    });

    expect(mockedConfig.saveConfig).toHaveBeenCalledWith({
      apiKey: "jdb_sk_test_validkey",
      project: "custom",
      baseUrl: "https://custom.api.com",
    });
    spy.mockRestore();
  });
});
```

**Step 2: Run tests**

```bash
npm test
```

Expected: All tests pass.

**Step 3: Commit**

```bash
git add src/commands/login.test.ts
git commit -m "test: add integration tests for login command"
```

---

### Task 11: Create CI Workflow

**Files:**
- Create: `.github/workflows/ci.yml`

**Step 1: Write the workflow**

```yaml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  ci:
    name: Lint, Test & Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - run: npm ci

      - name: Lint
        run: npm run lint

      - name: Check formatting
        run: npm run format:check

      - name: Typecheck
        run: npm run typecheck

      - name: Build
        run: npm run build

      - name: Test
        run: npm test
```

**Step 2: Verify locally that all steps pass**

```bash
npm run lint && npm run format:check && npm run typecheck && npm run build && npm test
```

Expected: All green.

**Step 3: Commit**

```bash
git add .github/workflows/ci.yml
git commit -m "ci: add CI workflow with lint, format, typecheck, build, test"
```

---

### Task 12: Final Verification

**Step 1: Run the full CI pipeline locally**

```bash
npm ci && npm run lint && npm run format:check && npm run typecheck && npm run build && npm test
```

Expected: Clean run, all checks pass, all tests pass.

**Step 2: Verify build output is clean**

```bash
ls dist/
```

Expected: Only compiled `.js` and `.d.ts` files — no `.test.js` files (since we excluded them in tsconfig).

**Step 3: Verify no test files in dist**

```bash
find dist -name "*.test.*"
```

Expected: No results.
